[[异步]]


# 回调

## 一、什么是“回调”？先抛开术语

“回调”本质上就是：**你把一个函数的地址（或者说“入口点”）交给别人，让别人在某个合适的时机去调用它。**

听起来很简单对吧？但为什么初学者会觉得难？因为“函数”在这里不是静态地被调用，而是**作为数据传递**，并在未来某个不确定的时间点被执行。

------

## 二、从计算机底层看：函数是什么？

在计算机底层（比如 x86 或 ARM 架构），**函数其实就是一段内存中的指令序列**，而**函数名（或指针）就是这段指令的起始地址**。

举个例子（伪汇编）：

```asm
main:
    call foo        ; 调用 foo 函数
    ...

foo:
    mov eax, 1      ; foo 的第一条指令
    ret             ; 返回
```

`call foo` 实际上就是把 `foo` 的地址压入栈，然后跳转到那个地址开始执行。

所以，**函数 = 内存地址 + 可执行代码**。

------

## 三、函数可以作为“值”传递吗？

在高级语言（如 C、Python、JavaScript）中，你可以把函数当作参数传给另一个函数。这在底层是如何实现的？

以 C 语言为例：

```c
void my_callback() {
    printf("Hello from callback!\n");
}

void do_something(void (*fn)()) {
    // 这里 fn 是一个指向函数的指针
    fn(); // 调用它
}

int main() {
    do_something(my_callback); // 把 my_callback 的地址传进去
}
```

底层发生了什么？

- `my_callback` 是一个符号，编译后对应一个内存地址（比如 `0x401000`）。
- `do_something(my_callback)` 实际上传递的是这个地址。
- 在 `do_something` 内部，CPU 执行 `call [fn]` —— 即跳转到 `fn` 指向的地址执行。

✅ **关键点**：函数指针就是一个普通的值（地址），和其他整数、指针一样，可以存储、传递、比较。

------

## 四、为什么叫“回调”？谁“回”？“调”谁？

想象这样一个场景：

> 你（主程序）请快递员（库函数）送一个包裹，并说：“送到后，打这个电话（你的函数）通知我。”

- 你提前把“电话号码”（函数地址）告诉快递员。
- 快递员在**完成任务后**，主动“回拨”这个号码。
- 这个“回拨”动作，就是**回调**。

所以，“回调”强调的是：

- **控制流的反转**：通常是你调用别人；但这里，你让别人在合适的时候调用你。
- **异步或事件驱动**：回调常用于 I/O 完成、定时器触发、用户点击等“未来发生”的事件。

------

## 五、从 CPU 和操作系统角度看回调

### 1. 同步回调（普通函数指针）

- 就像上面 C 的例子，发生在同一个线程、同一个调用栈。
- CPU 直接 `call` 那个地址，和普通函数调用无异。

### 2. 异步回调（如网络请求、事件循环）

- 操作系统或运行时（如 Node.js、浏览器）维护一个**事件队列**。
- 当某个事件发生（如 socket 数据到达），系统从队列中取出对应的回调函数地址，并安排执行。
- 底层可能涉及中断、系统调用、上下文切换等，但最终仍是 **CPU 跳转到那个函数地址执行**。

例如，在 Linux 中，`epoll` 机制可以注册“当 fd 可读时，调用某个处理函数”。虽然中间经过内核调度，但最终还是通过函数指针调用你的代码。

------

## 六、类比帮助理解

| 概念        | 现实类比                     |
| ----------- | ---------------------------- |
| 主程序      | 你                           |
| 库函数/系统 | 快递公司                     |
| 回调函数    | 你的电话号码                 |
| 注册回调    | 告诉快递“送到后打这个电话”   |
| 触发回调    | 快递员送货完成，拨打你的电话 |

你不需要一直盯着快递（轮询），而是让它完成后再通知你——这就是回调的价值：**解耦 + 异步 + 事件驱动**。

------

## 七、总结：从第一性原理看回调

1. **函数在内存中就是一段可执行代码，有确定的入口地址。**
2. **这个地址可以像整数一样被存储、传递。**
3. **当你把这个地址交给别人，并让他们在未来某个时刻跳转过去执行，就形成了“回调”。**
4. **回调的本质是“控制权的暂时转移 + 事后归还”，是一种程序协作模式。**

------

如果你理解了“函数就是地址”、“调用就是跳转”，那么“回调”就不再神秘——它只是**把跳转的目标地址延迟决定，并由他人触发**。

希望这个解释能帮你打通底层逻辑！如果还有疑问，比如关于闭包、异步、事件循环如何与回调交互，也可以继续问。

