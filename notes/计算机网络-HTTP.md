[[计算机网络]]
### **与http相关的一些概念**

**浏览器（web Browser）：** 浏览器的本质是http中的请求方，使用http协议获得网络上的各种资源。在HTTP协议里，浏览器的角色被称为"User Agent"即用户代理，意思是作为访问者的”代理来发起HTTP请求。下图是一些主流浏览器及其内核。

**服务器（web Server)：** 硬件含义就是物理形式或“云”形式的机器。软件含义的 Web 服务器就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，返回动态的信息。常见的web服务器有Apache、Nginx。

**CDN（Content Delivery Network）：** CDN是为了解决长距离网络访问速度慢的问题而诞生的一种网络应用服务，全称为“内容分发网络”。CDN最核心的原则是“就近访问”，使用HTTP协议里的代理和缓存技术，<mark>用户在上网的时候不直接访问原网站，而是访问离他最近的一个CDN节点</mark>，节省了访问过程中的时间成本。（负载均衡，安全防护，边缘计算）.

**web Service：** 由W3C定义的应用服务开发规范，使用client-server主从架构。是一个基于Web（HTTP）的服务架构技术。

**DNS（Domain Name System）：** 域名系统，用有意义的名字来作为 IP 地址的等价替代。在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host）。域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。

**URI/URL：** URI（Uniform Resource Identifier）中文名称是统一资源标识符。DNS 和 IP 地址只是标记了互联网上的主机，URI能够唯一地标记互联网上资源。URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，通常不会做严格的区分。

**HTTPS：** 全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层，相当于“HTTP+SSL/TLS+TCP/IP”。

**代理（Proxy）:** 是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。

- 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；
- 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；
- 正向代理：靠近客户端，代表客户端向服务器发送请求；
- 反向代理：靠近服务器端，代表服务器响应客户端的请求；

### 域名

![图片](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640.webp)

### DNS

DNS就是用来将域名变为ip的协议。

NS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：

- 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回"com","net","cn"等顶级域名服务器的 IP 地址
- 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 cn 顶级域名服务器可以返回 123.cn域名服务器的 IP 地址；
- 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 123.cn 权威域名服务器可以返回 www.123.cn 的 IP 地址。

![图片](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747276482689-3.webp)

### **HTTP/1.X**

#### HTTP报文

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

- 起始行（*start line*）：描述请求或响应的基本信息；
- 头部字段集合（*header*）：使用 key-value 形式更详细地说明报文；
- 消息正文（*entity*）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

<div>
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747276617348-9.webp" alt="图片" style="zoom: 50%;" />
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747276648556-12.webp" alt="图片" style="zoom: 33%;" />
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747276864889-15.webp" alt="图片" style="zoom:70%;" />
</div>

#### HTTP请求方法

| 方法    | 说明                                 |
| ------- | ------------------------------------ |
| GET     | 获取资源，可以理解为读取或者下载数据 |
| HEAD    | 获取资源的元信息                     |
| POST    | 向资源提交数据，相当于写入或上传数据 |
| PUT     | 类似 POST                            |
| DELETE  | 删除资源                             |
| CONNECT | 建立特殊的连接隧道                   |
| OPTIONS | 列出可对资源实行的方法               |
| TRACE   | 追踪请求-响应的传输路径              |

> GET和HEAD
>
> - 1.GET适用于向服务器请求资源，一般将数据携带于url上。
> - 2.HEAD类似于简化版的GET请求，服务端收到HEAD请求时只返回响应头并且响应头与GET完全一致
>
> POST和PUT
>
> - 1.POST 适用于向服务端发送数据，将数据携带在body当中，通常表示的是“create”的含义
>
> - 2.PUT 类似于POST方法，也可以向服务器提交数据，是“update”的含义。
>
> GET和POST的区别:
>
> - **1. 大小：** GET通常将数据带在URL当中而POST将数据放在body里(是RFC在语义上的要求，语法上GET也可以使用body传输数据而POST同样可以把参数放在URL里)，因此由于浏览器对于URL长度的限制，GET请求能携带的数据大小一般不超过2KB。值得一提Chrome浏览器对URL的长度限制已经增加到2MB，但是我们考虑到兼容性，URL的长度应该以最大限制的最小标准为主（IE浏览器限制为2KB），除了浏览器的限制，还应该考虑到服务端的限制。
>
> - **2. 安全：** 安全是指请求的方法是否会对服务器当中的资源造成影响，因为GET方法是<mark>只读</mark>的，只要服务器没有“曲解”客户端的请求，服务端上的数据就是安全的。而POST会对服务端的数据进行“增删改”的操作，因此是不安全的。
>
> - **3. 幂等：** 幂等的意思是说多次重复执行操作，产生的效果是否相同。显然因为<mark>GET</mark>方法只对服务器上的资源做只读操作，因此是<mark>幂等的</mark>。POST在RFC中的定义是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的（而 PUT 是“替换或更新数据”，多次更新一个资源，所以是幂等的）。
>
> - **4. 缓存：** 就是说这个方法的可缓存性，绝大多数的浏览器的实现里仅仅<mark>支持GET缓存</mark>。因为GET因为是读取，就可以对GET请求的数据做缓存。而POST不幂等也就意味着不能随意多次执行。因此也就不能缓存。

#### URI

URI，也就是统一资源标识符（Uniform Resource Identifier）。

![图片](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747277421032-18.webp)

- **scheme** 协议名，表示资源应该使用哪种协议来访问。最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。

- **://** 分隔符，在 scheme 之后，必须是三个特定的字符“://”，它把 scheme 和后面的部分分离开。没有特定的意义。
- **user:passwd@** 身份信息
- **host:port** 主机名加端口号
- **path** 路径,表示资源所在位置
- **query** 查询参数用一个“?”开始，但不包含“?”，表示对资源附加的额外要求。path是多个“key=value”的字符串，这些字符串用字符“&”连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。
- **#fragment** 片段标识符，它是 URI 所定位的资源内部的一个“锚点”，浏览器可以在获取资源后直接跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。

#### HTTP的特点

1. 灵活可扩展
2. 可靠传输
3. 无状态: “状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。HTTP在整个协议里没有规定任何的“状态”，但不要忘了 HTTP 是“灵活可扩展”的，虽然标准里没有规定“状态”，但完全能够在协议的框架里给它“打个补丁”，增加这个特性(cookie)。

#### HTTP的实体数据

##### **数据类型**

- **Accept**:MINE将数据分为七大类（video、image、application、text、audio、multipart、message），再以type/subtype的格式细分出其下的子类。例如我们常用到的text/html 、text/css 、image/jpeg 、 applaction/json等。

- **Accept-encoding**:制定了数据的压缩格式(gzip、deflate、br)
- **Accept-Language**：标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：`Accept-Language: zh-CN, zh, en`

##### **数据类型在请求头中的表现**

在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段。

![图片](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747277878583-21.webp)

#### HTTP如何传输大文件

- 数据压缩
  `accept-encoding`：服务器可以选择一种浏览器支持的数据压缩方式放进`content-encoding`响应头里，再把原数据压缩后返回给客户端。
- 分块传输
  在HTTP头部表示为`Transfer-Encoding: chunked`,指报文里的body部分不是一次性发过来的，而是分为许多`chunked`分块发送。`Transfer-Encoding: chunked`和`Content-Length`这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。
- 范围请求
  如果想获取某个大文件其中的片段，分块传输就没办法满足这样的需求。HTTP协议提出了范围请求这样的概念，允许客户端只获取文件的某一部分。客户端先发个HEAD请求看看服务器是否支持范围请求，服务器必须在`Accept-Ranges`响应头中告知客户端是否具有范围请求的能力。请求头`Ranges`是HTTP范围请求的专用字段，值的格式是`bytes=x-y`表示`x ~ y`之间的范围。服务端在收到 `Ranges`请求头时，首先验证x-y的范围是否合法（x和y可以省略，省略x则表示从后往前，省略y则表示从前往后），其次计算读取偏移量，返回206状态码和所读取的文件 ，最后在响应头加上`Content-Range`表示实际返回的偏移量和总数,格式为`bytes x-y/length`。
  范围请求还支持在一个头里定义多个`x-y`,这种情况需要一种特殊的MIME类型`multipart/byteranges`,表示报文是有多段组成。

#### HTTP连接管理

##### **Connection：keep-alive**

HTTP1.1提出了长连接的概念，也就是`Keep-alive`。在长连接上建立一次TCP连接可以发送多个HTTP请求。但因为连接是`alive`的，如果一直不关闭，就会占用大量的服务器资源，导致服务无法及时响应真正的请求，所以我们也需要及时关闭连接。可以通过在客户端请求头添加`Connection: close`字段主动关闭连接。服务端通常不会主动关闭连接，但我们也可以通过设置时长、请求数等方式约定断开连接的条件。

##### **队头阻塞**

基于`请求-应答`模式的http协议，形成了串行的请求队列（`http1.1还提出了管道机制，即在同一个TCP连接上不用等待上一个请求的响应即可发出下个请求，不过客户端还是按照正常顺序接受响应，这种做法并没带来任何性能上的改善，所以默认保持关闭`），如果队首的请求处于阻塞状态，那么后面的请求也无法正常响应结果就是更长时间的性能浪费。

`并发连接`和`域名分片`是对队头阻塞的针对性优化策略，浏览器限制每个客户端可以并发建立6～8个连接，又可以将多个域名指向同一个服务器，这样实际的连接数量就更多了，是一种用数量解决质量的思路。

##### **重定向**

当我们在浏览器输入一个url再按下回车，页面跳转到我们输入的地址中，这种行为就是主动跳转。浏览器还支持被动跳转，也就是HTTP的重定向。

- `301`指永久重定向
- `302`指临时重定向
- `303`类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作。
- `307`类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确。
- `308`类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。

**客户端是如何处理重定向的**

![图片](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747278095355-24.webp)

#### cookie

cookie同样存在于HTTP头部字段里。服务端可以使用`set-cookie`标识客户端身份，客户端则在请求时携带`cookie`告诉服务端自己的信息。`cookie`字段以`key=value`的格式保存，浏览器在一个`cookie`字段里可以存放多对数据，用`;`分割。

![图片](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP.assets/640-1747278121400-27.webp)

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

##### **相关属性**

###### **生存周期**

`Expires`俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。

`Max-Age`用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。

`Expires` 和 `Max-Age` 可以同时出现，两者的失效时间不一致时浏览器会优先采用`Max-Age`计算失效期。如果服务器不设置Max-Age、Expries或者字段值为0指不能缓存cookie，但在会话期间是可用的，浏览器会话关闭之前可以用cookie记录用户的信息。

###### **作用域**

`Domain`和`Path`指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie。

###### **安全性**

`HttpOnly`表示此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问。这也是预防“跨站脚本”（XSS）攻击的有效手段。

`SameSite`可以防范“跨站请求伪造”（XSRF）攻击，`SameSite = strict`表示禁止cookie在跳转链接时跨域传输。`SameSite = lax`稍微宽松一点，允许在`GET`、`HEAD`等安全请求方式中跨域携带。默认值为`none`,表示不限制cookie的携带和传输。

`Secure`表示这个cookie仅能用HTTPS协议加密传输，明文的HTTP协议会禁止发送。但Cookie本身不是加密的，浏览器里还是以明文的形式存在。
