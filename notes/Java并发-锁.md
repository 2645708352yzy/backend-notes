[[Java并发]]
## 为什么需要锁？

锁用于对资源进行锁定，标识该资源当前已被占用。

在 JVM 中，堆内存和方法区是线程共享的区域，因此多个线程访问这些区域的数据时可能存在**数据竞争**问题。为了保证并发访问的安全性，Java 提供了锁机制。


## Java 的锁在哪？如何表示锁？

Java 中的锁信息存储在对象的对象头中。对象头主要包含两个部分：

- **Mark Word**：存储对象的运行时状态信息，如哈希码、GC 分代年龄、锁状态标志等。
- **Class Pointer**：指向类型元数据（即方法区中的 Class 信息）。

![MarkWord](Java%E5%B9%B6%E5%8F%91-%E9%94%81.assets/image-20250528213028998.png)

锁的状态通过 Mark Word 中的“锁标志位”来区分，具体有以下四种状态：

| 锁状态       | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| **无锁**     | 对象未被任何线程锁定。                                       |
| **偏向锁**   | Mark Word 中记录偏向线程的 ID，适用于只有一个线程访问同步块的情况。当多个线程竞争时，升级为轻量级锁。 |
| **轻量级锁** | 使用 CAS 操作将线程栈中的锁记录地址存入 Mark Word，适用于多个线程交替执行且不存在长时间竞争的情况。 |
| **重量级锁** | 线程进入阻塞状态，等待操作系统调度唤醒，适用于高竞争场景。   |

## Synchronized 的实现机制 - Monitor

`synchronized` 是 Java 中最常用的同步机制，其底层依赖于 **Monitor（监视器）** 实现。

![Monitor](Java%E5%B9%B6%E5%8F%91-%E9%94%81.assets/image-20250528213314845.png)

从 JDK 1.6 开始，`synchronized` 引入了一系列优化技术来减少锁操作的开销，包括：

- 自旋锁（Spin Lock）
- 适应性自旋锁（Adaptive Spin Lock）
- 锁消除（Lock Elimination）
- 锁粗化（Lock Coarsening）
- 偏向锁（Biased Lock）
- 轻量级锁（Lightweight Lock）

这些优化显著提升了 `synchronized` 的性能，使其在许多场景下可以媲美甚至超越显式锁（如 ReentrantLock）。

## 轻量级锁详解

当一个线程尝试获取轻量级锁时，会检查对象的锁标志位是否为 `00`（即轻量级锁状态），然后在线程栈中创建一个锁记录（Lock Record），并尝试通过 **CAS 操作** 将对象的 Mark Word 复制到锁记录中。

### 成功情况：
- 如果 CAS 成功，则对象头中写入锁记录地址和锁状态 `00`，表示线程成功持有锁。

### 失败情况：
- 如果 CAS 失败：
  - **其他线程已经持有了轻量级锁**，此时锁膨胀为重量级锁。
  - **当前线程重复进入 synchronized 代码块（重入）**，则会在栈中新增一条 Lock Record，作为重入计数器（如下图所示，有两个锁记录，表示重入次数为 2）。

## 重量级锁详解

当多个线程竞争同一个轻量级锁时，未获得锁的线程会进入**自旋等待**状态。如果自旋等待的线程数量超过一定阈值（通常是 10 次左右），轻量级锁就会**升级为重量级锁**。

在重量级锁状态下，后续请求锁的线程都会被挂起，进入操作系统内核态等待，直到锁被释放后由操作系统重新调度唤醒线程。

这种机制虽然避免了 CPU 空转浪费，但也会带来较高的上下文切换开销，因此应尽量避免锁升级到重量级阶段。

## 总结

Java 的锁机制是一个多层次的体系，主要包括：

- **偏向锁**：适用于单线程访问，减少同步开销。
- **轻量级锁**：适用于多线程交替执行，使用 CAS 避免阻塞。
- **重量级锁**：适用于高竞争场景，依赖操作系统调度。

合理利用这些锁机制，可以在不同并发场景下获得最佳性能表现。
