[[MySQL]]



## B树

示例： 使用 B 树索引查找一个键

![image-20250520143213339](MySQL-2-%E7%B4%A2%E5%BC%95.assets/image-20250520143213339.png)
## InnoDB的数据存储

### InnoDB按页来读取数据
#### 单个页的结构

<div>
<img src="MySQL-2-B+%E6%A0%91.assets/image-20250524225450276.png" alt="image-20250524225450276" style="zoom:45%;" />
<img src="MySQL-2-B+%E6%A0%91.assets/image-20250524225503043.png" alt="image-20250524225503043" style="zoom:45%;" />
</div>

#### File Header 将数据页连接成双向链表

![image-20250524225705155](MySQL-2-%E7%B4%A2%E5%BC%95.assets/image-20250524225705155.png)
#### 对数据页记录建立槽
**数据页中的记录按照「主键」顺序组成单向链表，检索效率不高，使用页目录对数据页的记录建立索引，提高检索效率**

<img src="MySQL-2-%E7%B4%A2%E5%BC%95.assets/image-20250524225940655.png" alt="image-20250524225940655" style="zoom:50%;" />

#### 页目录的创建过程

1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），**每个槽相当于指针指向了不同组的最后一个记录**。

#### 一个数据页中记录的查询示例
以上面的图为<mark>查询示例</mark>：

- 5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：
  - 先二分得出槽中间位是 (0+4)/2=2，2 号槽里最大的记录为 8。因为 11 > 8，所以需要从 2 号槽后继续搜索记录；
  - 再使用二分搜索出 2 号和 4 号槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 < 12，所以主键为 11 的记录在 3 号槽里；





### InnoDB采用B+树作为索引


当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。InnoDB 采用了 B+ 树作为索引。

#### B+树的结构

![image-20250521223528093](MySQL-2-%E7%B4%A2%E5%BC%95.assets/image-20250521223528093.png)

- 只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。
- 非叶子节点分为不同层次，通过分层来降低每一层的搜索量；
- 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询。

#### 查询示例

<mark>示例：</mark>B+ 树如何实现快速查找主键为 6 的记录:

- 从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7) 范围之间，所以到页 30 中查找更详细的目录项；
- 在非叶子节点（页 30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页 16）查找记录；
- 接着，在叶子节点（页 16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。

#### 聚簇索引和二级索引

- 聚簇索引的叶子节点存放的是**实际数据**，所有完整的用户记录都存放在聚簇索引的叶子节点；
- 二级索引的叶子节点存放的是**主键值**，而不是实际数据。

为了实现非主键字段的快速搜索，引出了二级索引

因此，**如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作<mark>「回表」</mark>，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作<mark>「索引覆盖」</mark>，也就是只需要查一个 B+ 树就能找到数据。**

#### 索引失效

![image-20250526125655069](MySQL-2-%E7%B4%A2%E5%BC%95.assets/image-20250526125655069.png)

##### like 关键字左或者左右模糊匹配无法走索引

**答：**因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。

##### 对索引使用函数

因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。

因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。

##### 对索引进行表达式计算

因为索引保存的是索引字段的原始值，而不是而不是表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。

##### 对索引隐式类型转换

如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。

MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。

**示例**

```SQL
select * from t_user where phone = 1300000001;
```

phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字,走全表扫描

```sql
select * from t_user where id = "1";
```

这时因为字符串部分是输入参数，也就需要将字符串转为数字,走索引扫描

##### 联合索引非最左匹配

**多个普通字段组合在一起创建的索引就叫做联合索引**，也叫组合索引。

**多个普通字段组合在一起创建的索引就叫做联合索引**，也叫组合索引。

创建联合索引时，我们需要注意创建时的顺序问题,因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。

联合索引要能正确使用需要遵循**最左匹配原则**,也就是按照最左优先的方式进行索引的匹配。

有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？

这种其实严格意义上来说是属于索引截断。

从 MySQL 5.6 之后，有一个**索引下推功能**，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。

##### WHERE 子句中的 OR

在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。