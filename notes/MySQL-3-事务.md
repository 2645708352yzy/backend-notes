[[MySQL]]

事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式。从概念上讲，事务中的所有读写操作被视作单个操作来执行：整个事务要么成功 **提交**（commit），要么失败 **中止**（abort）或 **回滚**（rollback）。

### ACID

原子性（Atomicity）:能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。

一致性（Consistency）:**对数据的一组特定约束必须始终成立**，即 **不变式（invariants）**。

持久性（Durability）:一旦事务提交，其结果将永久保存在数据库中，即使系统崩溃也不会丢失。

隔离性（Isolation）：同时执行的事务是相互隔离的：它们不能相互冒犯。



## MySQL如何实现ACID？

**A：**一次更新操作对应一条undo log，如果执行异常，则反向执行每次操作记录的undolog。

**I：**写写隔离、MVCC。

**C：**约束 + ACID 其他特性共同保障。

**D：**Redo Log + 刷盘策略。



## 事务隔离级别

- 读未提交
- 读已提交
- 可重复读
- 串行读

## 事务隔离

**术语：**

- 脏读：一个事务读取到另一个事务还未提交的数据。
- 不可重复读：一个事务的执行过程中，若对同一数据执行两次读取，出现数据不一致的情况。
- 幻读：见ACID。

### 读已提交

#### 读已提交 提供的保证

1. 没有 **脏读**
2. 没有 **脏写**

#### 实现 读已提交

数据库通过使用 **行锁（row-level lock）** 来<mark>防止脏写</mark>：当事务想要修改特定对象（行或文档）时，它必须首先获得该对象的锁。

<mark>防止脏读</mark>：对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。

#### 读已提交 的异常

使用此隔离级别时，仍然有很多地方可能会产生并发错误，使数据库出现数据不一致的状态。常见的情况是**不可重复读（nonrepeatable read）** 、**读取偏差（read skew）**

### 快照隔离

**快照隔离（snapshot isolation）**是不可重复度读问题最常见的解决方案。

#### 什么是快照隔离

每个事务都从数据库的 **一致快照（consistent snapshot）** 中读取 —— 也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。

#### 实现快照隔离

快照隔离的实现通常使用写锁来防止脏写。

数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它同时维护着单个对象的多个版本，所以这种技术被称为 **多版本并发控制（MVCC, multi-version concurrency control）**。

 PostgreSQL 如何实现基于 MVCC 的快照隔离：当一个事务开始时，它被赋予一个唯一的，永远增长 [^vii] 的事务 ID（`txid`）。每当事务向数据库写入任何内容时，它所写入的数据都会被标记上写入者的事务 ID。

#### 观察一致性快照的可见性规则

当一个事务从数据库中读取时，事务 ID 用于决定它可以看见哪些对象，看不见哪些对象。通过仔细定义可见性规则，数据库可以向应用程序呈现一致的数据库快照。工作如下：

1. 在每次事务开始时，数据库列出当时所有其他（尚未提交或尚未中止）的事务清单，即使之后提交了，这些事务已执行的任何写入也都会被忽略。
2. 被中止事务所执行的任何写入都将被忽略。
3. 由具有较晚事务 ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。
4. 所有其他写入，对应用都是可见的。

#### 索引和快照隔离

#### 可重复读与命名混淆

快照隔离是一个有用的隔离级别，特别对于只读事务而言。但是，许多数据库实现了它，却用不同的名字来称呼。在 Oracle 中称为 **可串行化（Serializable）** 的，在 PostgreSQL 和 MySQL 中称为 **可重复读（repeatable read）**。

### 防止丢失更新

并发的写入事务之间还有其他几种有趣的冲突。其中最著名的是 **丢失更新（lost update）** 问题：如果两个事务同时执行，则其中一个的修改可能会丢失，因为第二个写入的内容并没有包括第一个事务的修改。

#### 原子写

原子操作通常通过在读取对象时，获取其上的排它锁来实现。以便更新完成之前没有其他事务可以读取它。

#### 显式锁定

选择是让应用程序显式地锁定将要更新的对象。然后应用程序可以执行读取 - 修改 - 写入序列，如果任何其他事务尝试同时读取同一个对象，则强制等待，直到第一个 **读取 - 修改 - 写入序列** 完成。

#### 自动检测丢失的更新

原子操作和锁是通过强制 **读取 - 修改 - 写入序列** 按顺序发生，来防止丢失更新的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其 **读取 - 修改 - 写入序列**。

#### 比较并设置（CAS）

在不提供事务的数据库中，有时会发现一种原子操作：**比较并设置**（CAS, 即 Compare And Set，先前在 “[单对象写入](#单对象写入)” 中提到）。此操作的目的是为了避免丢失更新：只有当前值从上次读取时一直未改变，才允许更新发生。如果当前值与先前读取的值不匹配，则更新不起作用，且必须重试读取 - 修改 - 写入序列。

### 写入偏差与幻读

#### 写入偏差的特征

常见的写入偏差都遵循着类似的模式：

1. **查询状态**：一个  SELECT 查询找出符合条件的行，并检查是否符合一些要求。
2. **判断：**按照第一个查询的结果，应用代码决定是否继续执行操作
3. **执行操作：**执行写入（插入、更新、删除），并提交事务。

**当多个有着上述模式的事务并发执行时，就有可能会发生一个事务中的写入改变另一个事务的搜索查询的结果，被称为 <mark>幻读</mark>**

#### 解决方法-物化冲突

如果幻读的问题是没有对象可以加锁，也许可以人为地在数据库中引入一个锁对象。

它将幻读变为数据库中一组具体行上的锁冲突。

### 可串行化

可串行化（Serializability） 隔离通常被认为是最强的隔离级别。它保证即使事务可以并行执行，最终 的结果也是一样的，就好像它们没有任何并发性，连续挨个执行一样。。因此数据库保证，如果事务在单 独运行时正常运行，则它们在并发运行时继续保持正确 —— 换句话说，数据库可以防止 所有 可能的竞争条件。

#### 真的可串行化

在单个线程上按顺序一次只执行一个事务。

#### 两阶段锁定

大约 30 年来，在数据库中只有一种广泛使用的串行化算法：两阶段锁定（2PL，two-phase locking）:只要没有写入，就允许多个事务同时读取同一个对象;对象只要有写入（修改或删除），就需要 独占访问（exclusive access） 权限。

- 如果事务 A 读取了一个对象，并且事务 B 想要写入该对象，那么 B 必须等到 A 提交或中止才能继续（这确保 B 不能在 A 底下意外地改变对象）。
- 如果事务 A 写入了一个对象，并且事务 B 想要读取该对象，则 B 必须等到 A 提交或中止才能继续。

#### 两阶段锁的实现

读与写的阻塞是通过为数据库中每个对象添加锁来实现的。锁可以处于 **共享模式（shared mode）** 或 **独占模式（exclusive mode）**。锁使用如下：

- 若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。
- 若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果对象上存在任何锁，该事务必须等待。
- 如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得独占锁相同。
- 事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是 “两阶段” 这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。

由于使用了这么多的锁，因此很可能会发生：事务 A 等待事务 B 释放它的锁，反之亦然。这种情况叫做 **死锁（Deadlock）**。数据库会自动检测事务之间的死锁，并中止其中一个，以便另一个继续执行。被中止的事务需要由应用程序重试。

### 可串行化快照隔离

两阶段锁是一种所谓的 悲观并发控制机制（pessimistic） ：它是基于这样的原则：如果有事情可能出 错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。

**串行化快照隔离 **一种 乐观（optimistic） 的并发控制技术。在这种情况下，乐观意味着， 如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交 时，数据库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且 必须重试。只有可串行化的事务才被允许提交。
