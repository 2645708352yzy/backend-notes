[[Netty]]

### 传统 Linux 中的零拷贝技术

模拟一个场景，从文件中读取数据，然后将数据传输到网络上，那么传统的数据拷贝过程会分为哪几个阶段呢？

![image-20250519145459022](Netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D.assets/image-20250519145459022.png)

一共经历了**四次数据拷贝**：

- 当用户进程发起 read() 调用后，上下文从用户态切换至内核态。DMA引擎从文件中读取数据，并存储到内核态缓冲区，这里是**第一次数据拷贝**。
- 请求的数据从内核态缓冲区拷贝到用户态缓冲区，然后返回给用户进程。第二次数据拷贝的过程同时，会导致上下文从内核态再次切换到用户态。
- 用户进程调用 send()方法期望将数据发送到网络中，此时会触发第三次线程切换，用户态会再次切换到内核态，请求的数据从用户态缓冲区被拷贝到Socket 缓冲区。
- 最终 send()系统调用结束返回给用户进程，发生了第四次上下文切换。第四次拷贝会异步执行，从Socket 缓冲区拷贝到协议引擎中。

关键点：<mark>第二次和第三次拷贝是可以去除的，DMA引擎从文件读取数据后放入到内核缓冲区，然后可以直接从内核缓冲区传输到Socket 缓冲区。</mark>

在 Linux 中系统调用 sendfile()可以实现将数据从一个文件描述符传输到另一个文件描述符，从而实现了零拷贝技术。在Java 中也使用了零拷贝技术，它就是 NIO FileChannel 类中的 transferTo()方法，transferTo() 底层就依赖了操作系统零拷贝的机制，它可以将数据从FileChannel 直接传输到另外一个 Channel。

![image-20250519145800246](Netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D.assets/image-20250519145800246.png)

拷贝次数变化：DMA引擎从文件中读取数据拷贝到内核态缓冲区之后，由操作系统直接拷贝到 Socket缓冲区，不再拷贝到用户态缓冲区，所以数据拷贝的次数从之前的 4 次减少到 3次。



![image-20250519145917758](Netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D.assets/image-20250519145917758.png)

DMA引擎读取文件内容并拷贝到内核缓冲区，然后并没有再拷贝到 Socket缓冲区，只是将数据的长度以及位置信息被追加到 Socket 缓冲区，然后 DMA引擎根据这些描述信息，直接从内核缓冲区读取数据并传输到协议引擎中，拷贝次数从3次减到2次。

### Netty 的零拷贝技术

Netty中的零拷贝技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下5 个方面：

-   堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。
-   CompositeByteBuf 类，可以组合多个 Buffer对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer合并成一个大的 Buffer。
-   通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf对象，包装过程中不会产生内存拷贝。
-   ByteBuf.slice 操作与 Unpooled.wrappedBuffer 相反，slice操作可以将一个 ByteBuf 对象切分成多个 ByteBuf对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。
-   Netty 使用 FileRegion 实现文件传输，FileRegion 底层封装了<mark>FileChannel#transferTo()</mark> 方法，可以将文件缓冲区的数据直接传输到目标Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝，这属于操作系统级别的零拷贝。