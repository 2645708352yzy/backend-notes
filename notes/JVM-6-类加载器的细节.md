[[JVM]]
![img](JVM-6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%BB%86%E8%8A%82.assets/f1063a739064846562ec04d1a9059e12.png)

- 启动类加载器（Bootstrap ClassLoader）：负责加载Java 核心库
- 扩展类加载器（Extension ClassLoader）：负责加载Java的扩展类库
- 应用类加载器（Application ClassLoader）:系统默认的类加载器

### 自定义类加载器

设计原则

![图片](JVM-6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%BB%86%E8%8A%82.assets/1b13bce735b4e5e74a20a99dc8030f7e.jpg)

### 双亲委派模型

双亲委派模型是JVM类加载器进行类加载时遵循的基本原则。

- 先将加载请求委派给父类加载器。
- 当父类加载器没办法加载的时候，才由当前类加载器尝试加载。

> 通过双亲委派模型，核心类库由启动类加载器加载，避免不可信的类对核心类库造成破坏。
>
> 这种有层次的类加载器结构，确保同一个类只会被加载一次，保证了类的一致性。

**双亲委派流程**

1. 类加载请求：当 Class.forName() 或ClassLoader.loadClass() 方法被调用时，类加载器会根据类的全限定名来加载类。
2. 委派给父类加载器：类加载器首先将加载请求委派给父类加载器进行处理。
3. 父类加载器处理：父类加载器按照相同的委派机制，将加载请求继续委派给其父类加载器，直至达到顶层的启动类加载器。
4. 加载类：如果父类加载器无法加载类，当前类加载器会尝试自己加载类。如果加载成功，就返回加载的 Class 对象；如果加载失败，将会抛出 ClassNotFoundException 异常。

![图片](JVM-6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%BB%86%E8%8A%82.assets/95f5377d57647438ce25073cdaab2cbd.png)

**双亲委派应用场景**

1. **类加载隔离：**通过使用不同的类加载器加载不同的类，实现类加载的隔离性，避免类之间的互相影响和冲突。
2. **安全沙箱隔离**通过自定义类加载器实现安全沙箱的机制，对不可信的类进行隔离加载和限制权限，提高系统的安全性。
3. **动态扩展和插件化**通过自定义类加载器实现动态加载和卸载功能，实现系统的动态扩展和插件化，提升程序的灵活性和可扩展性。
4. **多版本隔离**通过使用不同的类加载器加载不同版本的类，实现在同一个程序中使用不同版本的库文件，避免版本冲突。