[[操作系统]]

虚拟化：**操作系统通过软件手段，为上层应用程序提供一种抽象的、简化了的、看似独占的硬件资源视图**。

---

### 一、 CPU 虚拟化 (CPU Virtualization)

**目标**：让多个进程（程序）看似在“同时”独占CPU运行。

**核心问题**：
*   **受限直接执行 (Limited Direct Execution)**：如何让程序在CPU上高效运行（直接执行机器指令），同时又能被操作系统控制（不能让它一直霸占CPU或做危险操作）？
*   **如何在进程间切换 (Switching Between Processes)**？

**关键技术与概念**：

1.  **机制 (Mechanism) vs. 策略 (Policy)**：
    *   **机制**：如何做？例如，上下文切换（Context Switch）、中断/异常处理、系统调用接口。
    *   **策略**：何时做？例如，调度算法（先来先服务FCFS、最短作业优先SJF、轮转RR、多级反馈队列MLFQ等）。书中有大量篇幅讨论各种调度策略及其优缺点。

2.  **系统调用 (System Calls)**：
    *   用户程序通过系统调用（如 `fork()`, `exec()`, `wait()`, `open()`, `read()`, `write()`, `close()` 等）请求操作系统服务。
    *   系统调用是用户态到内核态的受控入口，是虚拟化CPU的关键接口。

3.  **中断与异常 (Interrupts and Exceptions)**：
    *   **时钟中断 (Timer Interrupt)**：是实现分时复用、强制进程切换、防止某个进程独占CPU的关键硬件机制。操作系统在启动时会设置一个定时器，定期触发中断，将控制权从用户进程夺回（“抢占”），交给调度器决定下一个运行哪个进程。
    *   **异常 (Exception)**：如除零、非法指令等，也会导致控制权转到操作系统。

4.  **上下文切换 (Context Switch)**：
    *   当操作系统决定从进程A切换到进程B时，需要保存进程A的当前状态（寄存器值、程序计数器PC等），然后恢复进程B之前保存的状态，使其继续执行。
    *   这是实现“虚拟CPU”的核心操作，但本身是有开销的。

5.  **调度 (Scheduling)**：
    *   操作系统如何决定哪个进程在什么时候获得CPU资源。
    *   书中详细讨论了多种调度算法，从简单的FIFO、SJF，到更实用的轮转（Round Robin），再到复杂的多级反馈队列（Multi-Level Feedback Queue, MLFQ），后者能较好地平衡响应时间和吞吐量。

**总结CPU虚拟化**：操作系统通过硬件支持（中断、特权级）和软件机制（系统调用、上下文切换、调度器），在单个或多个物理CPU上，为多个进程营造出每个进程都拥有自己专属CPU的假象，并能公平、高效、安全地在它们之间切换。

---

### 二、 内存虚拟化 (Memory Virtualization)

**目标**：让每个进程都感觉自己拥有一个巨大、连续、从地址0开始的私有内存空间，且进程间内存相互隔离，互不干扰。

**核心问题**：

*   如何为每个进程提供独立的地址空间？
*   如何实现内存保护（一个进程不能访问另一个进程或操作系统的内存）？
*   如何高效地利用有限的物理内存？

**关键技术与概念**：

1.  **地址空间 (Address Space)**：
    *   每个进程看到的内存布局（代码、堆、栈等）是独立的、虚拟的。

2.  **动态重定位 (Dynamic Relocation) / 基址与界限寄存器 (Base and Bounds Registers)**：
    *   早期/简单的方案。硬件提供基址寄存器（Base）和界限寄存器（Bounds）。
    *   进程访问的虚拟地址 = 基址 + 逻辑地址。
    *   硬件在每次内存访问时自动进行地址转换，并检查是否越界。
    *   简单，但有内部碎片问题，且不支持非连续分配。

3.  **分段 (Segmentation)**：
    *   将程序按逻辑单元（代码段、堆段、栈段等）划分成多个段。
    *   每个段有自己的基址和长度。
    *   解决了部分内部碎片，支持更灵活的内存布局，但仍可能有外部碎片，管理复杂。

4.  **分页 (Paging)** —— **现代系统的主流方案**：
    *   将虚拟地址空间和物理地址空间都划分为固定大小的块，称为“页”（Page）和“页帧”（Page Frame）。
    *   通过**页表 (Page Table)** 建立虚拟页到物理页帧的映射。
    *   **地址转换**：硬件（MMU - Memory Management Unit）在程序访问内存时，自动根据页表将虚拟地址转换为物理地址。
    *   **优点**：
        *   完美解决了外部碎片问题。
        *   支持稀疏地址空间（虚拟地址空间可以很大，但只分配实际使用的页）。
        *   易于实现内存保护（页表项中设置权限位）。
        *   是实现交换（Swapping）和按需分页（Demand Paging）的基础。

5.  **页表优化**：
    *   **TLB (Translation Lookaside Buffer)**：页表通常很大，放在内存中，每次地址转换都要访问内存，太慢。TLB是MMU中的高速缓存，缓存最近使用的页表项，极大加速地址转换。
    *   **多级页表 (Multi-level Page Tables)**：避免为稀疏地址空间分配巨大的单级页表。只分配实际使用的部分，节省内存。
    *   **倒排页表 (Inverted Page Tables)**：以物理页帧为主键，适用于物理内存远小于虚拟地址空间的情况（较少用）。

6.  **交换 (Swapping) 与 按需分页 (Demand Paging)**：
    *   **交换**：当物理内存不足时，将暂时不用的进程（或其部分页）换出（Swap Out）到磁盘，腾出空间给其他进程；需要时再换入（Swap In）。
    *   **按需分页**：进程启动时，并不立即加载所有代码和数据到内存，只加载马上需要的页。当进程访问一个尚未加载的页时，会触发“缺页异常 (Page Fault)”，操作系统负责从磁盘（如可执行文件或交换空间）将该页加载到内存中，更新页表，然后让进程继续执行。这是实现“巨大虚拟地址空间”的关键。

7.  **页面置换算法 (Page Replacement Algorithms)**：
    *   当发生缺页且物理内存已满时，需要选择一个“牺牲页”换出到磁盘。
    *   常见算法：最优算法（OPT，理论最优）、先进先出（FIFO）、最近最少使用（LRU）、时钟算法（Clock，LRU的近似实现）等。
    *   目标是减少缺页率（Page Fault Rate）。

**总结内存虚拟化**：操作系统通过硬件（MMU、TLB）和软件（页表管理、缺页处理、页面置换）的紧密配合，为每个进程提供独立、受保护、看似连续且巨大的私有地址空间，同时高效地管理和利用有限的物理内存资源，并通过交换技术扩展了可用内存的容量。

---

### 三、 虚拟化的意义

1.  **易用性 (Ease of Use)**：程序员无需关心物理内存布局、CPU分配等底层细节，只需在自己“私有”的虚拟环境中编程。
2.  **安全性与保护 (Protection & Security)**：进程间、进程与内核间相互隔离，一个进程的崩溃或恶意行为不会直接影响其他进程或系统稳定性。
3.  **效率与性能 (Efficiency & Performance)**：通过分时复用CPU、按需分页、TLB缓存等技术，在保证隔离和易用的同时，尽可能提高资源利用率和系统性能。
4.  **资源管理 (Resource Management)**：操作系统作为“资源管理者”，通过虚拟化技术公平、高效地在多个竞争者（进程）间分配稀缺的硬件资源。
